1101
1010

1000

int n = 13;
int n1 = 10
|= 亦或运算	n != n1	(15)
&= 与运算	n &= n1 (8)
^= 非运算	n ^= n1 (7) 

git 把本地项目关联远程
1、git remote add origin https://github.com/ios-zhouyu/VueDemo.git
2、git add .
3、git commit -m 'comment'
4、git pull
5、git push -u origin master

res.locals 是 Express 提供的请求层对象， 可以将数据输出给模板， 很想 app.locals

多个事务都提交引发的丢失更新成为第二类丢失更新
一个事务回滚另外一个事务提交而引发的数据不一致的情况, 称之为第一类丢失更新
1. 未提交读, 允许一个事务读取另外一个事务没有提交的数据. 未提交读是一种危险的隔离级别, 所以一般在我们实际的开发中应用不光, 但是他的有点在于并发能力高, 适合那些对数据一致性没有要求而追求高并发的场景, 他的最大的画出是出现脏读
2. 读写提交, 是指一个事务只能读取另外一个事务已经提交的数据, 不能读取为提交的数据
3. 可重复读, 客服读写提交中出现的不可重复读的现象. 因为在读写提交的时候, 可能出现一些值得变化, 影响当前事务的执行, 这个时候数据库提出了可重复读的隔离级别.
4. 串行化, 他会要求所有的 SQL 都会按照顺序执行, 这样就可以克服上述隔离级别出现的各种问题, 所以它能够完全保证数据的一致性.

```
DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。
　　要把外设的数据读入内存或把内存的数据传送到外设，一般都要通过CPU控制完成，如CPU程序查询或中断方式。利用中断进行数据传送，可以大大提高CPU的利用率。
　　但是采用中断传送有它的缺点，对于一个高速I/O设备，以及批量交换数据的情况，只能采用DMA方式，才能解决效率和速度问题。DMA在外设与内存间直接进行数据交换，而不通过CPU，这样数据传送的速度就取决于存储器和外设的工作速度。
　　通常系统的总线是由CPU管理的。在DMA方式时，就希望CPU把这些总线让出来，即CPU连到这些总线上的线处于第三态–高阻状态，而由DMA控制器接管，控制传送的字节数，判断DMA是否结束，以及发出DMA结束信号。DMA控制器必须有以下功能：
　　1. 能向CPU发出系统保持（HOLD）信号，提出总线接管请求；
　　2. 当CPU发出允许接管信号后，负责对总线的控制，进入DMA方式；
　　3. 能对存储器寻址及能修改地址指针，实现对内存的读写操作；
　　4. 能决定本次DMA传送的字节数，判断DMA传送是否结束
　　5. 发出DMA结束信号，使CPU恢复正常工作状态。
```

